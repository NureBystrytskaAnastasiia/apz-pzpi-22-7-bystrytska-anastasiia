Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
 
 
  
Кафедра ПІ
 

 
Дисципліна «Архітектура програмного забезпечення»
Практична робота №1
«Шаблон (патерн) проєктування Proxy»
 
 
  
 
Виконала:
ст. гр. ПЗПІ-22-7
Бистрицька А.І	 	Прийняв:
ст. викл. кафедри ПІ
Сокорчук І.П
 

 
Харків – 2025
1 ІСТОРІЯ ЗМІН

№	Дата 	Версія	Опис змін	Автор
1	03.05.25	0.1	Було створено розділ «Завдання».	Бистрицька Анастасія
2	03.05.25	0.1	Було створено розділ «Опис виконаної робо-ти».	Бистрицька Анастасія
3	03.05.25	0.1	Було створено розділ «Висновки з роботи»	Бистрицька Анастасія
4	03.05.25	0.1	Було створено розділ «Додаток А»	Бистрицька Анастасія
5	03.05.25	0.1	Було створено розділ «Додаток Б»	Бистрицька Анастасія

2 ЗАВДАННЯ
У рамках практичної роботи №1 з дисципліни «Архітектура програ-много забезпечення» було завдання дослідити патерн проєктування Proxy. Необхідно було вивчити його структуру, основні принципи та застосуван-ня в реальних проєктах. Зокрема, важливо було зрозуміти взаємодію між Proxy та реальним об'єктом, а також коли і чому доцільно застосовувати цей патерн. Завдання також включало оцінку переваг і недоліків патерну Proxy та розвиток навичок аналізу та представлення технічної інформації.

3 ОПИС ВИКОНАНОЇ РОБОТИ
У процесі роботи було досліджено та проаналізовано патерн проєк-тування "Proxy" (Проксі). Цей патерн належить до категорії структурних патернів проєктування, описаних у книзі "Шаблони проєктування" (Gang of Four).
3.1  Що таке Proxy?
Proxy — це структурний патерн проєктування, який забезпечує замі-ну реального об’єкта спеціальним замінником. Клієнт взаємодіє не з самим об’єктом, а з його проксі.
Проксі може перевіряти права доступу перед передачею запиту. Це корисно для захисту чутливих даних або обмеження дій користувача. Він також дозволяє реалізувати кешування для зменшення навантаження на си-стему. При повторному запиті проксі повертає збережений результат без виклику основного об’єкта. Ще одна роль проксі — логування запитів, щоб відслідковувати дії користувача. Це корисно для аудиту або налаго-дження. 
Проксі підтримує "ліниве створення" об’єкта, відкладаючи ініціаліза-цію до першого запиту. Це економить ресурси при складному створенні об'єктів.
3.2 Призначення патерна
Однією з ключових функцій проксі є контроль доступу до об’єкта. У цьому випадку проксі перевіряє права користувача перед наданням досту-пу до методів реального об’єкта, що особливо актуально в системах з під-вищеними вимогами до безпеки та авторизації.
Ще одним важливим застосуванням є реалізація лінивого ініціювання (Lazy Initialization), коли створення ресурсоємного об’єкта відкладається до моменту його фактичного використання. Це дозволяє ефективно вико-ристовувати ресурси, уникаючи зайвих витрат на створення об’єктів, які можуть не знадобитися.
Проксі також виконує функцію кешування, зберігаючи результати попередніх викликів методів. Це знижує навантаження на систему та приш-видшує повторні запити, наприклад, при роботі з базами даних.
Крім того, проксі може реалізовувати логування запитів — фіксацію інформації про звернення до об’єкта, включаючи час, параметри та корис-тувача. Така функціональність є корисною для відстеження дій у системах, що потребують аудиту.
Ще одна важлива роль проксі — захист від несанкціонованого або небезпечного доступу. Це може включати блокування викликів методів, які потенційно можуть призвести до порушення стабільності чи безпеки сис-теми.
Нарешті, проксі може застосовуватися для реалізації віддаленого до-ступу (Remote Proxy), коли об’єкт знаходиться у віддаленій системі, на-приклад, на сервері. У такому разі проксі забезпечує зручний інтерфейс для роботи з віддаленим ресурсом, приховуючи деталі мережевої взаємодії.
3.3 Структура патерна
Структура патерну Proxy базується на чотирьох ключових компоне-нтах, які взаємодіють через спільний інтерфейс. Така організація дозволяє клієнту працювати з об'єктами незалежно від того, чи є вони реальними сервісами, чи їх замінниками.
Клієнт (Client) взаємодіє з об’єктом через загальний інтерфейс, не маючи потреби знати, чи працює він із проксі чи безпосередньо з реальним сервісом. Наприклад, код програми може викликати метод operation(), не переймаючись внутрішньою реалізацією.
Інтерфейс сервісу (ServiceInterface) визначає контракт, якого мають дотримуватися і проксі, і реальний об’єкт. Цей інтерфейс, наприклад Payment, містить методи, такі як pay(), які реалізуються однаково як у про-ксі, так і в основному сервісі.
Проксі (Proxy) містить посилання на реальний об’єкт та виконує функцію посередника, який контролює доступ до нього. Проксі може пере-віряти права доступу, додавати кешування, логування або відкладене зава-нтаження, наприклад, у класі PaymentProxy, що перевіряє баланс перед ви-конанням оплати.
Реальний сервіс (RealService) — це безпосередній виконавець запи-ту, який реалізує бізнес-логіку. У випадку з платіжною системою це може бути клас BankPayment, що напряму працює з фінансовими транзакціями.
3.4  Види Proxy
У патерні Proxy існує кілька різновидів, кожен з яких вирішує окремі задачі, пов’язані з контролем доступу, оптимізацією продуктивності або додатковими діями при викликах об’єкта.
Віртуальний Proxy (Virtual Proxy) використовується для відкладе-ного створення ресурсомістких об'єктів до моменту їх фактичного викори-стання. Це зменшує витрати пам’яті та часу на етапі ініціалізації, напри-клад, при завантаженні великих зображень або встановленні з’єднання з ба-зою даних.
Захищаючий Proxy (Protection Proxy) реалізує контроль доступу на основі ролей або прав користувача. Він перевіряє автентифікацію та авто-ризацію перед передачею запиту реальному об’єкту, що корисно, напри-клад, для обмеження доступу до адміністративних функцій.
Віддалений Proxy (Remote Proxy) забезпечує взаємодію з об’єктами, розміщеними у віддалених системах, з використанням локаль-ного інтерфейсу. Це дозволяє, наприклад, працювати з банківським API або викликати методи віддалених сервісів за допомогою технологій CORBA чи RMI.
Кешуючий Proxy (Cache Proxy) зберігає результати попередніх ви-кликів для зменшення навантаження на систему та прискорення відповіді. Його застосування доцільне при кешуванні SQL-запитів або API-відповідей з динамічних сервісів, таких як погодні сервіси.
Смарт-посилання (Smart Reference) виконує додаткові дії під час кожного звернення до об’єкта. Зокрема, може підраховувати кількість ак-тивних посилань або автоматично звільняти ресурси, коли об’єкт більше не використовується.
3.5 Переваги та недоліки
Серед основних переваг можна виділити можливість додавання фу-нкціоналу (такого як кешування, логування або перевірка доступу) без змі-ни коду клієнта або реального об’єкта. Наприклад, можна реалізувати ау-дит викликів API без втручання в його логіку. Крім того, Proxy підтримує роботу з неініціалізованими об’єктами, дозволяючи відкладене створення ресурсомістких екземплярів, що зменшує стартові витрати на ресурси. Ще однією перевагою є керування життєвим циклом об’єктів: проксі може ав-томатично створювати або знищувати об’єкти, оптимізуючи використання пам’яті, наприклад, закриваючи неактивні з’єднання з базою даних.
Попри це, патерн має і недоліки. Насамперед, це ускладнення архі-тектури, оскільки вимагає створення додаткових класів (інтерфейсів і обго-рток), що може бути надмірним для простих задач. Крім того, додаткові рівні логіки (перевірки, кешування, логування) можуть знижувати продук-тивність системи, збільшуючи час відповіді навіть при простих операціях.
3.6 Приклад застосування
Сценарій використання Proxy для кешування даних з бази даних
Одним із практичних застосувань патерну Proxy є реалізація механі-зму кешування при взаємодії з базою даних. У такому випадку проксі ви-ступає посередником між клієнтом і реальним джерелом даних, оптимізу-ючи доступ до інформації.
Під час запиту клієнт викликає метод отримання даних (наприклад, getData(id)), не маючи знання про те, чи обробляється запит безпосередньо базою даних або через проміжний об'єкт. У першу чергу запит надходить до об'єкта Proxy, який перевіряє наявність запитуваних даних у кеші (лока-льному або зовнішньому, як-от Redis). Якщо дані вже збережені, вони мит-тєво повертаються клієнту, що дозволяє суттєво зменшити час відповіді. Такий підхід особливо ефективний у випадках повторних звернень до по-пулярних ресурсів, наприклад, для отримання інформації про найпопуляр-ніші товари в онлайн-магазині.
Якщо ж необхідні дані відсутні в кеші, проксі передає запит до реа-льного сервісу (наприклад, RealDatabaseService), який здійснює доступ до бази даних. Після отримання результату проксі не тільки передає відповідь клієнту, а й зберігає дані в кеші для обробки майбутніх аналогічних запи-тів. Це дозволяє уникнути повторних обчислень або складних SQL-запитів, знижуючи навантаження на систему та покращуючи продуктивність.
3.7 Сценарій застосування Proxy
Патерн Proxy широко використовується в різних сценаріях для пок-ращення ефективності, безпеки та зручності взаємодії з об'єктами. Один із найбільш поширених варіантів використання — ліниве завантаження ве-ликих об'єктів. Віртуальний Proxy відкладає створення ресурсомістких об'-єктів до моменту їх реального використання. Це дозволяє знижувати ви-трати ресурсів, наприклад, завантажуючи великі зображення у вебдодатках лише при їх відображенні або ініціалізуючи підключення до бази даних тільки при першому запиті.
Інший важливий сценарій — захист API через авторизацію та аутен-тифікацію. Захищаючий Proxy перевіряє права доступу користувача перед тим, як викликати методи основного об'єкта. Це забезпечує контроль дос-тупу до чутливих даних або адміністративних функцій, наприклад, переві-рка JWT-токена перед доступом до мікросервісу або обмеження редагу-вання даних для звичайних користувачів.
Кешування складних операцій також є важливим випадком засто-сування Proxy. Кешуючий Proxy зберігає результати запитів для уникнення повторних обчислень і значного зменшення часу відгуку. Це особливо ко-рисно при виконанні важких SQL-запитів або при роботі з зовнішніми API, наприклад, зберігання даних з API погоди на певний час.
Ще одним популярним сценарієм є логування звернень, де Proxy фіксує інформацію про виклики методів, що дозволяє проводити аудит дій користувачів або збирати статистику для налагодження. Це включає моні-торинг дій користувачів або ведення журналу запитів для аналізу.
Патерн Proxy також активно використовується для роботи з відда-леними сервісами, таких як RPC або REST API. Віддалений Proxy інкап-сулює мережеві виклики, забезпечуючи прозору взаємодію з об'єктами, які знаходяться на віддалених серверах. Це дозволяє працювати з такими сер-вісами, як банківські API чи мікросервіси, використовуючи локальний ін-терфейс.
Нарешті, Proxy може бути застосований у аспектно-орієнтованому програмуванні (AOP), коли додаткову логіку, таку як транзакції в базі да-них або вимірювання часу виконання методів, додають через перехоплення викликів методів без зміни основного коду.
3.8 Альтернативи
Патерн Декоратор (Decorator) є альтернативою до Proxy в тих випадках, коли потрібно динамічно додавати нову функціональність до об'єкта. На відміну від Proxy, який контролює доступ і може додавати до-даткову логіку, Декоратор зосереджений на розширенні поведінки об'єкта без змін основної логіки або життєвого циклу. Декоратор додає функціо-нальність об'єкту, наприклад, для форматування тексту або додавання валідації без зміни оригінального класу.
Патерн Адаптер (Adapter) є схожим на Proxy, оскільки працює як проміжний шар між клієнтом та об'єктом, але його основна мета — це змінити інтерфейс об'єкта для досягнення сумісності з іншими частинами системи. Відмінність від Proxy полягає в тому, що Адаптер не додає нової логіки або функціональності, а лише змінює інтерфейс для інтеграції, наприклад, для адаптації старої платіжної системи до нового API.
Патерн Фасад (Facade) також спрощує взаємодію з об'єктами, як і Proxy, але замість контролю доступу до окремих компонентів він об'єднує кілька підсистем в один простий інтерфейс. Фасад приховує складність взаємодії з великими системами або фреймворками, забезпечуючи простіший доступ до функціональності, наприклад, для роботи з CRM-системою. На відміну від Proxy, Фасад не контролює доступ або життєвий цикл об'єктів, а просто об'єднує їх під єдиним інтерфейсом для спрощення роботи з ними.
4 ВИСНОВКИ З РОБОТИ
Під час роботи було детально розглянуто патерн Proxy (Проксі), йо-го основні аспекти, включаючи структуру, варіанти використання та доці-льність застосування. Аналізувались його основні компоненти, такі як клі-єнт, інтерфейс сервісу, проксі та реальний сервіс, а також переваги і недо-ліки цього паттерну. Було розглянуто різні види Proxy, зокрема віртуаль-ний, захищаючий, віддалений та кешуючий проксі, а також сценарії їх ви-користання, такі як кешування, захист доступу і лінійне завантаження. Та-кож було наведено приклади застосування цього паттерну у вигляді коду на TypeScript.
 
ДОДАТОК А
Відеозапис доповіді на YouTube: https://youtu.be/leMoAarDMvA
Хронологічний опис доповіді:
00:00 Вступна частина
00:14 Зміст 
00:28 Що таке патерн Proxy 
01:46 Аналогія з життя 
02:47 Призначення патерна 
04:10 Структура патерна 
05:14 Види Proxy 
05:57 Переваги та недоліки 
06:51 Приклад застосування 
08:06 Приклад застосування - код 
08:54 Приклад застосування - код 
09:53 Сценарії використання 
11:30 Альтернативи 
12:38 Висновки 
12:54 Джерела інформації
 
ДОДАТОК Б
Слайди презентації доповіді 
 
Рисунок Б.1 – Титульний слайд презентації
 
Рисунок Б.2 – Зміст презентації
 
Рисунок Б.3 –  Визначення поняття Proxy
 
Рисунок Б.4 –  Аналогія з життя
 
Рисунок Б.5 –  Призначення патерна
 
Рисунок Б.6 –  Структура патерна
 
Рисунок Б.7 –  Види Proxy
 
Рисунок Б.8 – Переваги та недоліки
 
Рисунок Б.9 – Приклад затосування 
 
Рисунок Б.10 – Приклад затосування  код
 
Рисунок Б.11 – Приклад затосування  код
 
Рисунок Б.12 – Сценарій використання
 
Рисунок Б.13 – Альтернативи
 
Рисунок Б.14 – Висновки
 
Рисунок Б.15 – Подяка  та використанні джерела інформації
 
ДОДАТОК В 
Програмний код 
interface Database {
    query(sql: string): any;
}

class RealDatabase implements Database {
    query(sql: string): any {
        console.log(`Executing query: ${sql}`);
        // Реальна логіка запиту до БД
        return { data: "result from DB" };
    }
}
class DatabaseProxy implements Database {
    private realDatabase: RealDatabase;
    private cache: Map<string, any> = new Map();
    
    query(sql: string): any {
        if (this.cache.has(sql)) {
            console.log(`Returning cached result for: ${sql}`);
            return this.cache.get(sql); 
        }
        
        if (!this.realDatabase) {
            this.realDatabase = new RealDatabase();
        }
        
        const result = this.realDatabase.query(sql);
        this.cache.set(sql, result);
        return result;
    }
}






